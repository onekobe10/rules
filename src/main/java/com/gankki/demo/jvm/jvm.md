# JVM

#### 内存泄漏(Memory Leak) & 内存溢出（Memory Overflow）
1. 内存泄露是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。
2. 内存溢出指程序申请内存时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。也就是说给你个int类型的存储数据大小的空间，但是却存储一个long类型的数据，这样就会导致内存溢出。
##### 关系
1. 内存泄漏的堆积最终会导致内存溢出
2. 内存溢出就是你申请的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。
3. 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。
4. 内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错，
##### 内存溢出的原因
1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据，因此数据一定要分页查询
2. 有其他对集合类中某个对象的引用，使用完后未清空，就会导致JVM不能回收整个集合容器的内存
3. 代码中存在死循环或循环产生过多重复的对象实体
4. 使用的第三方软件中的BUG
5. 启动参数内存值设定的过小
##### 内存泄漏的原因
1. 在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用），这是所有语言都有可能会出现的内存泄漏方式。
2. 长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露 
3. 各种提供了close方法的对象，如数据库连接、网络连接、io连接，如果不显示关闭，GC是不会回收这些内存资源的。
```
// 这里 method1 执行结束后，由于对象的引用被成员变量引用了，所以这个 Object 对象只有在 Simple 对象实例被 GC 回收时才会回收 method1 中的 Object 对象，因此我们要根据实际情况尽量缩小变量的作用域。
public class Simple {
    Object object;
    public void method1(){
        object = new Object();
        //...其他代码
    }
// 这里 sessionFactory 会返回一个 创建好的 session 的 引用，如果这个 session 没有手动关闭，就会导致 JDBC 的连接等资源一直没有被释放，同时这个 session 的内存也不能被回收，这就是内存泄漏了。
try{
    session=sessionFactory.openSession();
    //...其他操作
}finally{
    session.close();

```

#### Java 运行时内存分布
1. 程序计数器（Program Counter Register）
2. Java 虚拟机栈（Java Virtual Machine Stacks）
3. 本地方法栈（Native Method Stack）
4. Java 堆（Java Heap）
5. 方法区（Method Area）
6. 运行时常量池（Runtime Constant Pool）
7. 直接内存（Direct Memory）

# 总结
1. 使用内存查看工具动态查看内存使用情况
2. 运行时内存分布和常量池 第二章


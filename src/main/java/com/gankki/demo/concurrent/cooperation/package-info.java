package com.gankki.demo.concurrent.cooperation;

/**
 *	cooperation mechanism 协作机制
 *
 * 	生产者/消费者协作模式：
 * 		这是一种常见的协作模式，生产者线程和消费者线程通过共享队列进行协作，生产者将数据或任务放到队列上，
 * 		而消费者从队列上取数据或任务，如果队列长度有限，在队列满的时候，生产者需要等待，而在队列为空的时候，消费者需要等待。
 * 	等待结束：
 * 		主从协作模式也是一种常见的协作模式，主线程将任务分解为若干个子任务，为每个子任务创建一个线程，
 * 		主线程在继续执行其他任务之前需要等待每个子任务执行完毕。
 * 	异步结果：
 * 		在主从协作模式中，主线程手工创建子线程的写法往往比较麻烦，
 * 		一种常见的模式是将子线程的管理封装为异步调用，异步调用马上返回，
 * 		但返回的不是最终的结果，而是一个一般称为Promise或Future的对象，通过它可以在随后获得最终的结果。
 *
 *  Object中定义了两类线程协作的方法，wait()/notify()
 *
 *  每个对象都有一把锁和等待队列，一个线程在进入synchronized代码块时，会尝试获取锁，获取不到的话会把当前线程加入等待队列中，
 *  其实，除了用于**锁的等待队列**，每个对象还有另一个等待队列，表示**条件队列**，该队列用于线程间的协作。
 *  调用wait就会把当前线程放到条件队列上并阻塞，表示当前线程执行不下去了，它需要等待一个条件，
 *  这个条件它自己改变不了，需要其他线程改变。当其他线程改变了条件后，应该调用Object的notify/notifyAll方法
 *	notify做的事情就是从条件队列中选一个线程，将其从队列中移除并唤醒，notifyAll和notify的区别是，它会移除条件队列中所有的线程并全部唤醒。
 *
 *	***wait/notify方法只能在synchronized代码块或方法内被调用，
 *	如果调用wait/notify方法时，当前线程没有持有对象锁，会抛出异常java.lang.IllegalMonitorStateException。***
 *
 *  你可能会有疑问，如果wait必须被synchronized保护，那一个线程在wait时，
 *   另一个线程怎么可能调用同样被synchronized保护的notify方法呢？它不需要等待锁吗？
 *   我们需要进一步理解wait的内部过程，虽然是在synchronized方法内，但调用wait时，线程会释放对象锁，wait的具体过程是：
 *
 * 		1.把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING
 * 		2.等待时间到或被其他线程调用notify/notifyAll从条件队列中移除，这时，要重新竞争对象锁
 * 			1.如果能够获得锁，线程状态变为RUNNABLE，并从wait调用中返回
 * 		 	2.否则，该线程加入对象锁等待队列，线程状态变为BLOCKED，只有在获得锁后才会从wait调用中返回
 * 			(调用notify会把在条件队列中等待的线程唤醒并从队列中移除，但它不会释放对象锁，
 * 			也就是说，只有在包含notify的synchronized代码块执行完后，等待的线程才会从wait调用中返回。)
 *
 * 	wait/notify方法发与一个共享的条件变量有关，这个条件变量是程序自己维护的，
 * 	当条件不成立时，线程调用wait进入条件等待队列，另一个线程修改了条件变量后调用notify，唤醒在等待的线程，
 * 	调用wait的线程唤醒后需要重新检查条件变量。
 * 	从多线程的角度看，它们围绕共享变量进行协作，
 * 	从调用wait的线程角度看，它阻塞等待一个条件的成立。
 * 	我们在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。
 *
 *
 */
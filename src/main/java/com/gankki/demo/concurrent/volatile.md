# volatile  
 /'vɑlətl/ n.挥发物 adj.不稳定的，反复无常的
 
**关键字volatile可以认为是Java虚拟机提供的罪轻量级的同步机制。**

#### volatile关键字的两个特性
1. 保证此变量对所有线程的可见性
    >"可见性"是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在内存中间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。
2. 禁止指令重排序优化
    >普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值的操作顺序与程序代码中的执行顺序完全一致        
    >volatile读操作的性能消耗与普通变量几乎没有差别，但是写操作则可能会慢一些，为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。内存屏障（Memory Barrier/Fence,指重排序时不能把后面的指令重排序到内存屏障之前的位置。）        
    >大多数场景下，volatile的总开销仍然比锁低
    
**volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中。**

volatile在各个线程中是一致的：     
volatile变量在各个线程的工作内存（虚拟机栈）中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用的之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），**但是java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。**

race++详解

```
0: getstatic    #13;//Field race:1
3: iconst_1
4: iadd
5: putstatic    #13;//Field race:1
```
当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。

工作内存（栈内存）、缓存内存、主内存

volatile在不符合以下情况的运算场景时，仍需要通过加锁来保证原子性：
1. 运算结果不依赖变量当前的值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他变量共同参与不变约束。
package com.gankki.demo.concurrent.sync;

/**
 *	当多个线程并发访问共享资源的操作为非原子操作时，由于竞态条件的存在，会导致结果不符合逾期，这个问题可以用synchronized来解决
 *
 *	synchronized实例方法实际保护的是同一个对象的方法调用，确保同时只能有一个线程执行。
 *	再具体来说，synchronized实例方法保护的是当前实例对象，即this，this对象有一个锁和一个等待队列，
 *	锁只能被一个线程持有，其他试图获得同样锁的线程需要等待，执行synchronized实例方法的过程大概如下：
 *
 *  	1.尝试获得锁，如果能够获得锁，继续下一步，否则加入等待队列，阻塞并等待唤醒
 *  	2.执行实例方法体代码
 *  	3.释放锁，如果等待队列上有等待的线程，从中取一个并唤醒，如果有多个等待的线程，唤醒哪一个是不一定的，不保证公平性
 *
 *  当前线程不能获得锁的时候，它会加入等待队列等待，线程的状态会变为BLOCKED。
 *
 *   *** synchronized保护的是对象而非代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被同步顺序访问。
 *  此外，需要说明的，synchronized方法不能防止非synchronized方法被同时执行
 *
 *	 synchronized保护的是对象，对实例方法，保护的是当前实例对象this，
 *	 对静态方法，保护的是哪个对象呢？是类对象，这里是StaticCounter.class，
 *	 实际上，每个对象都有一个锁和一个等待队列，类对象也不例外。
 *
 *	 synchronized静态方法和synchronized实例方法保护的是不同的对象，不同的两个线程，可以同时，
 *	 一个执行synchronized静态方法，另一个执行synchronized实例方法。***
 *
 *	 synchronized同步的对象可以是任意对象，任意对象都有一个锁和等待队列，或者说，任何对象都可以作为锁对象。
 *
 *	synchronized： 可重入性、内存可见性、死锁
 *	 可重入性
 *	 	synchronized有一个重要的特征，它是可重入的，也就是说，对同一个执行线程，
 *	 	它在获得了锁之后，在调用其他需要同样锁的代码时，可以直接调用，
 *	 	比如说，在一个synchronized实例方法内，可以直接调用其他synchronized实例方法。
 *	 	可重入是一个非常自然的属性，应该是很容易理解的，之所以强调，是因为并不是所有锁都是可重入的
 *	 内存可见性
 *	 	对于复杂一些的操作，synchronized可以实现原子操作，避免出现竞态条件
 *	 	*** synchronized除了保证原子操作外，它还有一个重要的作用，就是保证内存可见性，
 *	 	在释放锁时，所有写入都会写回内存，而获得锁后，都会从内存中读最新数据。***
 *		不过，如果只是为了保证内存可见性，使用synchronized的成本有点高，有一个更轻量级的方式，那就是给变量加修饰符volatile
 *			加了volatile之后，Java会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。
 *	 死锁
 *	 	使用synchronized或者其他锁，要注意死锁.
 *	 	比如，有a, b两个线程，a持有锁A，在等待锁B，而b持有锁B，在等待锁A，a,b陷入了互相等待，最后谁都执行不下去,所谓死锁就是类似这种现象，
 *		解决办法：首先，应该尽量避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁
 *
 *
 */
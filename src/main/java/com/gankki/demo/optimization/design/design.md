# 设计模式优化

#### 1. 线程上下文设计模式
1. 线程上下文是指贯穿线程整个生命周期的对象中的一些全局信息。
例如，我们比较熟悉的 Spring 中的 ApplicationContext 就是一个关于上下文的类，
它在整个系统的生命周期中保存了配置信息、用户信息以及注册的 bean 等上下文信息。
2. 可以使用 ThreadLocal 实现线程上下文。
ThreadLocal 是线程本地变量，可以实现多线程的数据隔离。
ThreadLocal 为每一个使用该变量的线程都提供一份独立的副本，线程间的数据是隔离的，每一个线程只能访问各自内部的副本变量。
3. 在数据库读写分离的业务场景中，则经常会用到 ThreadLocal 实现动态切换数据源操作。但在使用 ThreadLocal 时，我们需要注意内存泄漏问题
#### Thread-Per-Message 设计模式
1. Thread-Per-Message：就是每个*消息*一个线程的意思。
例如，我们在处理 Socket 通信的时候，通常是一个线程处理事件监听以及 I/O 读写，如果 I/O 读写操作非常耗时，这个时候便会影响到事件监听处理事件。
这个时候 Thread-Per-Message 模式就可以很好地解决这个问题，一个线程监听 I/O 事件，每当监听到一个 I/O 事件，则交给另一个处理线程执行 I/O 操作。

#### Worker-Thread 设计模式
1. Worker Thread：会有一些工人（线程）不断轮流处理过来的工作，当没有工作时，工人则会处于等待状态，直到有新的工作进来。除了工人角色，Worker Thread 设计模式中还包括了流水线和产品。
2. 这种设计模式相比 Thread-Per-Message 设计模式，可以减少频繁创建、销毁线程所带来的性能开销，还有无限制地创建线程所带来的内存溢出风险。
3. 假设一个物流仓库的物流分拣流水线上有 8 个机器人，它们不断从流水线上获取包裹并对其进行包装，送其上车。当仓库中的商品被打包好后，会投放到物流分拣流水线上，而不是直接交给机器人，机器人会再从流水线中随机分拣包裹。


#### 问题
1. 生产者消费者模式解读
2. 装饰器模式的实现解读
3. 从 JDK1.5 起，Java 就提供了一个 Future 类，它可以通过 get() 方法阻塞等待获取异步执行的返回结果，然而这种方式在性能方面会比较糟糕。在 JDK1.8 中，Java 提供了 CompletableFuture 类，它是基于异步函数式编程。相对阻塞式等待返回结果，CompletableFuture 可以通过回调的方式来处理计算结果，所以实现了异步非阻塞，从性能上来说它更加优越了。
> Future 和 CompletableFuture 同步阻塞和异步非阻塞的实现
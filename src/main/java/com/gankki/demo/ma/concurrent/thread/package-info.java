package com.gankki.demo.ma.concurrent.thread;

/**
 * thread intro
 * 线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。
 * run方法的方法签名是固定的，public，没有参数，没有返回值，不能抛出受检异常。
 * 	run方法类似于单线程程序中的main方法，线程从run方法的第一条语句开始执行直到结束。
 *
 * 为什么调用的是start，执行的却是run方法呢？
 * 	start表示启动该线程，使其成为一条单独的执行流，背后，操作系统会分配线程相关的资源，每个线程会有单独的程序执行计数器和栈，
 * 	操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行，执行的起点就是run方法。
 *
 * 如果不调用start，而直接调用run方法呢？屏幕的输出并不会发生变化，
 * 	但并不会启动一条单独的执行流，run方法的代码依然是在main线程中执行的，run方法只是main方法调用的一个普通方法。
 *
 * 成本
 * 	关于线程，我们需要知道，它是有成本的。创建线程需要消耗操作系统的资源，操作系统会为每个线程创建必要的数据结构、栈、程序计数器等，创建也需要一定的时间。
 * 	线程调度和切换也是有成本的，当有当量可运行线程的时候，操作系统会忙于调度，为一个线程分配一段时间，执行完后，再让另一个线程执行，
 * 	一个线程被切换出去后，操作系统需要保存它的当前上下文状态到内存，上下文状态包括当前CPU寄存器的值、程序计数器的值等，
 * 	而一个线程被切换回来后，操作系统需要恢复它原来的上下文状态，整个过程被称为 上下文切换 ，这个切换不仅耗时，而且使CPU中的很多缓存失效，是有成本的。
 *
 */
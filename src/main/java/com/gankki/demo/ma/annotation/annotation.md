# Annotation 注解

1. 注解提升了Java语言的表达能力，有效地实现了应用功能和底层功能的分离，框架/库的程序员可以专注于底层实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作。
2. 实际上，所有的注解类型，内部实现时，都是扩展的Annotation。所以可以使用Annotation接口来表示注解
3. 注解通过简单的声明就能达到某种效果，类似于序列化机制中通过简单的Serializable接口，Java就能自动处理很多复杂的事情。也类似于并发中的synchronized关键字，通过它可以自动实现同步访问，是一种声明式的编程风格。

声明式编程风格，在这种风格中，程序都由三个组件组成：
1. 声明的关键字和语法本身
2. 系统/框架/库，它们负责解释、执行声明式的语句
3. 应用程序，使用声明式风格写程序

元注解，只能在注解对象上使用的注解

#### @Target
@Target表示注解的目标，@Override的目标是方法(ElementType.METHOD)，ElementType是一个枚举，其他可选值有：
1. TYPE：表示类、接口（包括注解），或者枚举声明
2. FIELD：字段，包括枚举常量
3. METHOD：方法
4. PARAMETER：方法中的参数
5. CONSTRUCTOR：构造方法
6. LOCAL_VARIABLE：本地变量
7. ANNOTATION_TYPE：注解类型
8. PACKAGE：包
> 目标可以有多个，用{}表示。如果没有声明@Target，默认为适用于所有类型。

#### @Retention 保留
@Retention表示注解信息保留到什么时候，取值只能有一个，类型为RetentionPolicy，它是一个枚举，有三个取值：
1. SOURCE：只在源代码中保留，编译器将代码编译为字节码文件后就会丢掉
2. CLASS：保留到字节码文件中，但Java虚拟机将class文件加载到内存时不一定会在内存中保留
3. RUNTIME：一直保留到运行时
> 如果没有声明@Retention，默认为CLASS。@Override和@SuppressWarnings都是给编译器用的，所以@Retention都是RetentionPolicy.SOURCE。

#### @Inherited 
与接口和类不同，注解不能继承。有一个与继承有关的元注解@Inherited           
##### 注意
1. 如果使用注释类型来注释除类之外的任何内容，则此元注释类型不起作用。       
2. 这个元注释只会导致从超类继承注释; 已实现的接口上的注释无效。 
> 只有继承有效，接口的实现类，重写的方法都无效，使用范围较窄。
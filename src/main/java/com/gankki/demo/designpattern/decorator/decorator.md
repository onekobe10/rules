# 装饰模式 Decorator Pattern

Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.
在保持相同接口的条件不变的条件下，动态给一个对象添加一些额外的职责，装饰模式相比通过子类来扩展功能提供了更灵活的选择。

#### 装饰模式的优点
1. 装饰类和被装饰类可以独立发展，而不会相互耦合
2. **装饰模式是继承关系的一个替代方案。不管装饰了多少层。返回的对象类型还是原始对象的类型，实现的还是is-a的关系**
3. 装饰模式可以动态地扩展一个实现类的功能
#### 装饰模式的使用场景
1. 需要扩展一个类的功能，或给一个类添加附加功能
2. 需要动态地给一个对象添加功能，这些功能可以再动态地撤销
3. 需要为一批兄弟类进行改装或者加装功能，首选装饰模式    避免出现两层以上的继承
#### 最佳实践
1. 装饰模式是对继承的有力补充，装饰模式可以代替类的继承，解决类膨胀的问题       
2. 继承是静态地给类添加新的功能，装饰模式是动态地添加功能
3. 扩展性非常好

#### Gankki's Note
1. **在装饰模式中，必然有一个最基本、最核心、最原始的接口或者抽象类充当Component抽象构件**
2. 如果每个类新增功能时都通过继承实现，会导致类的数量激增，类爆炸。且类中功能的实现顺序固定，不能随意修改，需要更改时只能新增实现类，非常不灵活。
3. 装饰模式中会有针对接口的专门抽象类，新功能的扩展只需要实现抽象类即可，与原始类的耦合性降到了最低。
4. **类/抽象类中默认的构造方法是无参的，如果新增了有参数的构造方法，且没有显式声明无参的构造方法，就会导致实现类/继承抽象类时只能使用它们已声明的构造方法，不能再使用无参的构造方法，可以通过这种方式强制在子类中使用规定的父类的构造方法。**

